<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Minecraft</title>
    <style>
        body { 
            margin: 0; 
            background: linear-gradient(to bottom, #87CEEB 0%, #98D8E8 70%, #E0F6FF 100%); 
            font-family: 'Courier New', monospace; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 20px;
        }
        canvas { 
            border: 3px solid #4A5D23; 
            background: #000;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #info { 
            color: #333; 
            background: rgba(255,255,255,0.9); 
            padding: 15px; 
            border-radius: 10px; 
            margin-bottom: 10px;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>üü´ 2D Minecraft</h3>
        WASD / –°—Ç—Ä–µ–ª–∫–∏: –¥–≤–∏–∂–µ–Ω–∏–µ | –õ–ö–ú: –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∑–µ–º–ª—é | –ü–ö–ú: –∫–æ–ø–∞—Ç—å | R: –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –º–∏—Ä–∞
    </div>
    <canvas id="game" width="1000" height="600"></canvas>
    
    <script>
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const BLOCK_SIZE = 32;
        const WORLD_WIDTH = 200;
        const WORLD_HEIGHT = 50;
        let world = [];
        let camera = { x: 0, y: 0 };

        // –ò–≥—Ä–æ–∫
        const player = { 
            x: 100 * BLOCK_SIZE, 
            y: 20 * BLOCK_SIZE, 
            width: BLOCK_SIZE * 1.5, 
            height: BLOCK_SIZE * 2, 
            speed: 4,
            velY: 0,
            grounded: false
        };

        // –ö–ª–∞–≤–∏—à–∏
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'r') generateWorld();
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        // –ú—ã—à—å
        canvas.addEventListener('click', placeBlock);
        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            removeBlock(e);
        });

        function generateWorld() {
            world = [];
            for (let x = 0; x < WORLD_WIDTH; x++) {
                world[x] = [];
                // –ü–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å —Å —Ö–æ–ª–º–∞–º–∏
                const height = Math.floor(35 + Math.sin(x * 0.05) * 5 + Math.sin(x * 0.1) * 2);
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    if (y > height) {
                        world[x][y] = 1; // –ó–µ–º–ª—è
                    } else if (y > height - 3) {
                        world[x][y] = 2; // –¢—Ä–∞–≤–∞
                    } else {
                        world[x][y] = 0; // –í–æ–∑–¥—É—Ö
                    }
                }
            }
        }

        function placeBlock(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = Math.floor((e.clientX - rect.left + camera.x) / BLOCK_SIZE);
            const my = Math.floor((e.clientY - rect.top + camera.y) / BLOCK_SIZE);
            if (mx >= 0 && mx < WORLD_WIDTH && my >= 0 && my < WORLD_HEIGHT) {
                world[mx][my] = 1;
            }
        }

        function removeBlock(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = Math.floor((e.clientX - rect.left + camera.x) / BLOCK_SIZE);
            const my = Math.floor((e.clientY - rect.top + camera.y) / BLOCK_SIZE);
            if (mx >= 0 && mx < WORLD_WIDTH && my >= 0 && my < WORLD_HEIGHT) {
                world[mx][my] = 0;
            }
        }

        function update() {
            // –î–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            let movingX = 0, movingY = 0;
            if (keys['a'] || keys['arrowleft']) movingX -= player.speed;
            if (keys['d'] || keys['arrowright']) movingX += player.speed;
            if (keys['w'] || keys['arrowup'] || keys[' ']) {
                if (player.grounded) player.velY = -12;
            }

            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –∏ –∫–æ–ª–ª–∏–∑–∏–∏
            player.velY += 0.8; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
            player.grounded = false;

            // X –¥–≤–∏–∂–µ–Ω–∏–µ
            player.x += movingX;
            if (player.x < 0) player.x = 0;
            if (player.x > WORLD_WIDTH * BLOCK_SIZE - player.width) player.x = WORLD_WIDTH * BLOCK_SIZE - player.width;

            // Y –¥–≤–∏–∂–µ–Ω–∏–µ –∏ –∫–æ–ª–ª–∏–∑–∏–∏
            player.y += player.velY;
            if (player.y > WORLD_HEIGHT * BLOCK_SIZE - player.height) {
                player.y = WORLD_HEIGHT * BLOCK_SIZE - player.height;
                player.velY = 0;
                player.grounded = true;
            }

            // –ö–∞–º–µ—Ä–∞ —Å–ª–µ–¥—É–µ—Ç –∑–∞ –∏–≥—Ä–æ–∫–æ–º
            camera.x = player.x - canvas.width / 2 + player.width / 2;
            camera.y = player.y - canvas.height / 2 + player.height / 2;
            if (camera.x < 0) camera.x = 0;
            if (camera.y < 0) camera.y = 0;
            if (camera.x > WORLD_WIDTH * BLOCK_SIZE - canvas.width) camera.x = WORLD_WIDTH * BLOCK_SIZE - canvas.width;
            if (camera.y > WORLD_HEIGHT * BLOCK_SIZE - canvas.height) camera.y = WORLD_HEIGHT * BLOCK_SIZE - canvas.height;
        }

        function render() {
            // –ù–µ–±–æ
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(1, '#E0F6FF');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // –ú–∏—Ä
            const startX = Math.max(0, Math.floor(camera.x / BLOCK_SIZE) - 1);
            const endX = Math.min(WORLD_WIDTH, Math.floor((camera.x + canvas.width) / BLOCK_SIZE) + 1);
            const startY = Math.max(0, Math.floor(camera.y / BLOCK_SIZE) - 1);
            const endY = Math.min(WORLD_HEIGHT, Math.floor((camera.y + canvas.height) / BLOCK_SIZE) + 1);

            for (let x = startX; x < endX; x++) {
                for (let y = startY; y < endY; y++) {
                    if (world[x] && world[x][y]) {
                        const screenX = x * BLOCK_SIZE - camera.x;
                        const screenY = y * BLOCK_SIZE - camera.y;
                        
                        if (world[x][y] === 1) {
                            ctx.fillStyle = '#8B4513'; // –ó–µ–º–ª—è
                            ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
                        } else if (world[x][y] === 2) {
                            ctx.fillStyle = '#228B22'; // –¢—Ä–∞–≤–∞
                            ctx.fillRect(screenX, screenY, BLOCK_SIZE, BLOCK_SIZE);
                            ctx.fillStyle = '#4A7C59'; // –¢–µ–Ω–∏
                            ctx.fillRect(screenX + 2, screenY + 2, BLOCK_SIZE - 4, BLOCK_SIZE - 4);
                        }
                    }
                }
            }

            // –ò–≥—Ä–æ–∫
            const px = player.x - camera.x;
            const py = player.y - camera.y;
            ctx.fillStyle = '#FFDBAC';
            ctx.fillRect(px, py, player.width, player.height);
            ctx.fillStyle = '#FF8C42'; // –û–¥–µ–∂–¥–∞
            ctx.fillRect(px + 4, py + player.height * 0.3, player.width - 8, player.height * 0.4);
            ctx.fillStyle = '#000';
            ctx.fillRect(px + 8, py + 8, 6, 6); // –ì–ª–∞–∑
            ctx.fillRect(px + player.width - 14, py + 8, 6, 6); // –ì–ª–∞–∑

            // –°–µ—Ç–∫–∞ –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–∏—è –±–ª–æ–∫–æ–≤ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
            const rect = canvas.getBoundingClientRect();
            const mx = Math.floor((canvas.width / 2 + (event ? event.clientX - rect.left : 0) - camera.x) / BLOCK_SIZE);
            const my = Math.floor((canvas.height / 2 + (event ? event.clientY - rect.top : 0) - camera.y) / BLOCK_SIZE);
            if (mx >= 0 && mx < WORLD_WIDTH && my >= 0 && my < WORLD_HEIGHT) {
                ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                ctx.lineWidth = 2;
                ctx.strokeRect(mx * BLOCK_SIZE - camera.x, my * BLOCK_SIZE - camera.y, BLOCK_SIZE, BLOCK_SIZE);
            }
        }

        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // –°—Ç–∞—Ä—Ç
        generateWorld();
        gameLoop();
    </script>
</body>
</html>
